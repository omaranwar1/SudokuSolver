# Sudoku Solver - Computer Vision Project

**CSCE 4603 Fundamentals of Computer Vision**  
**Omar Anwar, Amal Fouda, Ahmed Elbarbary, Farida Bey**

---

## 1) Introduction

End-to-end Sudoku solver from a single photo. The system:
- Cleans the image (noise, lighting, polarity, rotation).  
- Detects the grid with redundant strategies (contour-first, Hough fallback).  
- Straightens via homography and repairs missing lines.  
- Extracts digits using handcrafted template matching (no ML).  
- Solves the puzzle with a backtracking engine and overlays the solution.  

Design goals: robust to uneven lighting, moderate skew, partial grid breaks, and template-friendly OCR without training.

---

## 2) System Map

```
Input image
   └── preprocess (grayscale → denoise → brightness normalize → threshold → complete lines → optional rotation)
       └── grid detection (contour-based + line-based fallback, corner validation)
           └── perspective transform (square warp, quality scoring)
               └── grid reinforcement (fill missing lines post-warp)
                   └── OCR (template matching, duplicate cleanup, candidate selection)
                       └── solver (validated backtracking with step cap)
                           └── render solution + save intermediates
```

---

## 3) Key Modules

### preprocessing.py
- **Noise typing** (`detect_noise_type`): Gaussian vs salt-and-pepper; Laplacian variance used as strength proxy.  
- **Adaptive denoise** (`remove_gaussian_noise`, `remove_salt_pepper_noise`): NLM/bilateral stacks for Gaussian; multi-pass median for impulse noise with level-aware presets.  
- **Brightness normalization** (`normalize_brightness`): Gamma selected from mean brightness; optional local flat-field equalization; CLAHE auto-applied for low contrast.  
- **Polarity check**: Invert if dark-majority pixels indicate white-on-black content.  
- **Thresholding**: Standard adaptive Gaussian for typical scenes; **subimage Otsu/adaptive grid** (`adaptive_threshold_subimages`) for noisy/uneven illumination.  
- **Grid completion** (`complete_grid_lines`): Morphological open/dilate for orthogonal lines, blending back and sealing gaps.  
- **Rotation** (`detect_rotation_robust` + `apply_rotation`): Hough-based angle estimation with conservative confidence; only rotates when horizontal/vertical medians agree.  
- **Outputs**: original image, enhanced grayscale (for warping), binary mask (for detection/OCR).

### grid_detection.py
- **Contour path** (`find_largest_contour` → `find_grid_corners`): convex hull, multi-epsilon polygon approximation, merge close vertices, extreme-corner fallback, geometry validation (distinctness, convexity, angle bounds), ordered TL-TR-BR-BL.  
- **Line path** (`detect_grid_using_lines`): Hough lines → angle split → clustering with outlier removal (`cluster_lines_improved`, `remove_line_outliers`, `select_grid_lines`) → corners from boundary intersections; equation-based refinement gated by aspect ratio.  
- **Quality checks**: squareness tolerance (`validate_grid_is_square`), transform quality score, in-bounds clipping.  
- **Occlusion detector** (`detect_blocked_corners`): compares contour vs line corners to flag blocked vertices.  
- **Visualization**: overlay 9×9 lines on detected quadrilateral (`draw_9x9_grid_lines`).  
- **Reinforcement helpers**:  
  - `reinforce_grid_morphological`: extend detected lines, add missing ones if coverage is low, preserve digits.  
  - `reinforce_grid_hough`: re-detect lines post-warp and extend to full span.  
  - `reinforce_grid_adaptive`: scan expected 10 line positions; fill when coverage <30% (gap-driven).  
  - `draw_template_grid`: synthetic 9×9 mask for severe breaks.

### perspective_transform.py
- Homography via `cv2.getPerspectiveTransform` / `warpPerspective` to a square (default 450×450).  
- Quality scoring (`get_transform_quality_score`) from side ratios and angle consistency; `apply_adaptive_transform` can reject low-quality grids.  
- `visualize_transformation` helper for side-by-side debug plots.

### ocr.py (pipeline default)
- **Template source**: PNGs in `digit_templates/` generated by `scripts/generate_digit_templates.py`; optional stroke augmentations.  
- **Cell extraction**: split straightened binary grid into 81 cells; remove grid bleed by clearing borders; keep the largest blob (digit).  
- **Matching**: weighted NCC + optional IoU/hole-count penalties to disambiguate 6/8/9 variants; supports multiple templates per digit.  
- **Conflict resolution** (`resolve_conflicts`): drop duplicates in rows/cols/blocks based on confidence scores; warns when conflicts remain.  
- **Debug**: `score_cell_against_templates` for per-digit scores; saves cell crops when `--no-save` is not set.

### ocr_pattern.py (standalone strict matcher)
- Normalizes a single cell to centered 50×50 glyphs, isolates largest component, and matches via weighted NCC + IoU with gap/threshold gating.  
- Useful for unit-testing templates or integrating OCR separately.

### solver.py
- Validates givens to catch duplicate numbers in rows/cols/blocks before search.  
- Depth-first backtracking with `_is_valid` constraints; configurable step cap (default 200k) to avoid runaway searches.  
- Returns solved board or an explicit failure reason.

### sudoku_solver.py (orchestrator/CLI)
- Drives the full pipeline: preprocess → detect grid (contour-first, line fallback) → warp → reinforce → OCR (contour vs line candidate selection) → solve → render.  
- Stores intermediate artifacts (original, preprocessed, contour viz, straightened color/binary, reinforced binary, solved overlay, optional cell crops).  
- Warns on low givens (<15) and unsolved boards; selects OCR candidate with fewer conflicts and more givens.

---

## 4) Algorithms and Parameters (selected)

- **Noise thresholds**: Laplacian variance gates denoise presets (e.g., >40k = heavy NLM + bilateral for Gaussian).  
- **Brightness**: Gamma choices: 3.5 (very dark), 2.5 (dark), 1.0 (normal), 0.6 (too bright) + CLAHE when std <40.  
- **Adaptive thresholding**: block size 15, C=3 for Gaussian adaptive; subimage grid defaults to 4×4 with Otsu when bimodal.  
- **Grid area filter**: contour must exceed 20% of image area.  
- **Corner geometry**: internal angles constrained (60°–120°); corners must be distinct; convexity enforced.  
- **Line clustering**: tolerance ~10 px; outliers removed via IQR; target 10 lines per axis with even-spacing heuristic.  
- **Reinforcement**: missing line drawn when coverage <10% (morph) or <30% (adaptive gap fill); full synthetic grid used if extended-line pixels are extremely sparse.  
- **OCR acceptance**: weighted NCC/IoU scoring; rejection when top score below threshold or gap to second-best too small (protects against ambiguous strokes).  
- **Solver cap**: default 200,000 recursive expansions; early exit if invalid givens.

---

## 5) Usage & CLI

```bash
# Full pipeline on a photo
python -m src.sudoku_solver --image 01.jpg --output output/

# Change straightened grid size (default 450)
python -m src.sudoku_solver --image 01.jpg --size 600

# Skip saving intermediates
python -m src.sudoku_solver --image 01.jpg --no-save

# OCR only on a pre-straightened binary grid (digits white on black)
python -m src.sudoku_solver --image binary_grid.png --binary-grid
``` 

Dependencies: `pip install -r requirements.txt`.

---

## 6) Outputs
- `_original.jpg`: resized input.  
- `_preprocessed.jpg`: binary mask used for detection/OCR.  
- `_contour_detection.jpg`: detected contour or line-corner overlay.  
- `_grid_9x9_visualization.jpg`: expected line overlay on detected quad.  
- `_straightened.jpg`: warped, brightness-enhanced color grid.  
- `_straightened_binary.jpg`: warped binary grid; `_reinforced` variant when gaps were filled.  
- `_cells/` (optional): per-cell crops used in OCR.  
- `_solved_overlay.jpg`: solution rendered over the straightened grid.

---

## 7) Troubleshooting & Tips
- **Grid not found**: ensure Sudoku is the largest quadrilateral; improve contrast; reduce perspective (>45° tilt can fail).  
- **Warp looks skewed**: check squareness message; low transform quality means corner detection was weak—retake with better framing.  
- **Missing lines post-warp**: enable saving intermediates to see `_reinforced` output; reinforcement fills gaps if coverage is low.  
- **OCR errors**: check cell crops; add or regenerate templates in `digit_templates/`; ambiguous digits with low gap may zero-out.  
- **Low givens warning**: <15 detected digits often signal poor OCR; fix detection before trusting solves.  
- **Unsolved puzzle**: message will state whether search capped out or givens were invalid (duplicates).

---

## 8) Extending or Reusing
- Swap OCR: plug `ocr_pattern.match_cell` for stricter single-cell checks or integrate a different matcher at `extract_grid_digits`.  
- Tune reinforcement: thresholds in `reinforce_grid_adaptive`/`reinforce_grid_morphological` control how aggressively lines are filled.  
- Adjust solver: change `max_steps` in `solve_puzzle` or swap in a constraint-propagation solver.  
- Instrumentation: use `visualize_transformation` or saved intermediates for notebook-style reports.

---

## 9) Limitations & Assumptions
- Sudoku grid should be dominant and reasonably axis-aligned; extreme perspective or heavy occlusion can defeat both detectors.  
- Handwritten/stylized digits outside the template family may require new templates or relaxed thresholds.  
- Rotation correction is conservative; slight residual skew may remain if Hough evidence is weak.  
- Works best with even lighting; severe shadows can force aggressive thresholding that erodes thin strokes.

---


## 10) Conclusion

This project demonstrates a full classical-CV pipeline that starts with a noisy photo and ends with a solved Sudoku rendered back onto the grid—without relying on trained models. Robust preprocessing, redundant grid detection, perspective correction, line reinforcement, and template-driven OCR work together to handle real-world artifacts like uneven lighting, partial line breaks, and moderate skew. The modular design (separable OCR, reinforcement, solver, and CLI) makes it easy to tune thresholds, swap components, or port the pipeline to other structured-grid problems. Continued refinement can focus on richer templates for handwritten digits, smarter conflict resolution, and tighter quality gating to make the solver even more tolerant of challenging captures.  